# Redis

Redis是一种基于内存的数据结构存储系统，也是一个开源的**NoSQL数据库**，支持键值(key-value)存储方式。它主要用于**缓存、消息队列、实时数据处理**等场景。Redis支持多种数据结构，**如字符串(String)、哈希(Hash)、列表(List)、集合(Set)、有序集合(ZSet)**等。它还提供了事务、Lua脚本、持久化、复制、高可用等功能。

## **Redis的特点：**

1. 快速：Redis是一个基于内存的数据结构存储系统，因此非常快速，读写性能都非常高。
2. 简单：Redis提供了简单易用的API，使得开发人员可以很容易地使用它。
3. 可扩展性好：Redis支持分布式部署，可以在多台服务器上搭建Redis集群，从而实现数据的高可用和负载均衡。
4. 支持多种数据结构：Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。
5. 丰富的功能：Redis提供了事务、Lua脚本、持久化、复制、高可用等功能，可以满足不同场景下的需求。
6. 社区活跃：Redis拥有庞大的社区，有很多优秀的第三方工具和库，可以方便地扩展和定制Redis。

## **使用场景：**

Redis（Remote Dictionary Server）是一种高性能的键值存储系统，常用于构建缓存、消息队列、计数器、分布式锁等场景。Redis 具有以下几个主要的使用场景：

1. 缓存：Redis 最常见的使用场景之一就是作为缓存，可以存储大量的键值对，缓存访问数据，以提高访问速度。
2. 计数器：Redis 还可以用于实现高并发的计数器，比如统计某个网站的在线人数、点赞数、阅读量等。
3. 消息队列：Redis 的 List 数据类型可以作为消息队列的实现方式之一，支持多个消费者对队列中的消息进行消费，实现高吞吐量的消息传递。
4. 分布式锁：利用 Redis 的原子操作可以实现分布式锁，避免多个客户端同时对同一个资源进行操作。
5. 排行榜：Redis 的有序集（ZSet）合可以轻松实现排行榜的功能，可以根据不同的排序规则进行排序，比如按照分数、时间等进行排序。
6. 地理位置应用：Redis 提供了 geohash 算法支持地理位置计算和查询，可以实现周边搜索、距离计算等功能。
7. 分布式会话存储：利用 Redis 的高性能和可靠性，可以将分布式系统中的会话数据存储在 Redis 中，实现分布式会话管理。

总的来说，Redis 适用于需要高速读写、键值对存储的场景，同时支持多种数据结构和操作，是构建高性能、可靠的分布式应用的重要工具之一。

## Redis常用数据类型及使用场景案例 ⭐️

- 字符串：适合存储简单的键值对，比如存储用户信息、配置信息等。
- (值如果是数字，可以递增incr或者递减decr)

```bash
127.0.0.1:6379> set key value
OK
127.0.0.1:6379> get key
"value"
127.0.0.1:6379> set n 2
OK
127.0.0.1:6379> incr n
(integer) 3
127.0.0.1:6379> decr n
(integer) 2
127.0.0.1:6379> decr n
(integer) 1
127.0.0.1:6379> get n
"1"
127.0.0.1:6379> set key a
OK
127.0.0.1:6379> incr key
(error) ERR value is not an integer or out of range
127.0.0.1:6379>
```

- 哈希表：适合存储结构化数据，比如存储用户的各种属性，如姓名、性别、年龄等。

```bash
127.0.0.1:6379> clear
127.0.0.1:6379> hset user name blake age 20
(integer) 2
127.0.0.1:6379> hget user name
"blake"
# 获取user对象
127.0.0.1:6379> hgetall user
1) "name"
2) "blake"
3) "age"
4) "20"
127.0.0.1:6379>
```

- 列表：适合存储列表型数据，比如存储一些实时的操作日志或者消息队列等。
  - 存储实时操作日志

```bash
# 从列表左边插入一条实时操作日志
LPUSH logs "2023-04-11 10:30:12 UserA logged in"

# 从列表右边插入一条实时操作日志
RPUSH logs "2023-04-11 10:31:23 UserB logged out"

# 获取最新的5条操作日志
LRANGE logs 0 4

# ===============================
# 实现消息队列

# 从队列右边取出一条消息
LPOP logs 
# 从队列右边取出一条消息
RPOP logs
```

- 集合：适合存储唯一性数据，比如存储一个用户的所有好友列表。

```bash
# 存储用户A的好友列表
127.0.0.1:6379> sadd friends:userA userB
(integer) 1
127.0.0.1:6379> sadd friends:userA userC
(integer) 1
127.0.0.1:6379> sadd friends:userA userD userE
(integer) 2
# 重复添加对redis来说是无效操作，不会提示，不会报错。但是返回0表示没有执行操作
127.0.0.1:6379> sadd friends:userA userE
(integer) 0
# 查看所有好友列表
127.0.0.1:6379> smembers friends:userA
1) "userD"
2) "userB"
3) "userE"
4) "userC"
127.0.0.1:6379>
```

- 有序集合：适合存储需要排序的数据，比如存储热门文章的阅读量排行榜。

```bash
# 向有序集合中添加文章阅读量
127.0.0.1:6379> ZADD articles:views 100 "article1"
(integer) 1
127.0.0.1:6379> zadd articles:views 50 "article2"
(integer) 1
127.0.0.1:6379> zadd articles:views 200 "article3"
(integer) 1
# 获取阅读量排行榜前三名的文章，并且使用withscores参数获取每篇文章的阅读量
127.0.0.1:6379> zrevrange articles:views 0 2 withscores
1) "article3"
2) "200"
3) "article1"
4) "100"
5) "article2"
6) "50"
# 只获取排名前三的文章名称: 如果想查询全部，从高到低的话，参数为 0 -1
127.0.0.1:6379> zrevrange articles:views 0 2
1) "article3"
2) "article1"
3) "article2"
# article2排名第几（排名从0开始）
127.0.0.1:6379>zrank articles:views article1  
1) 0

```

在这个示例中，我们使用有序集合（Sorted Set）数据结构实现排行榜功能。为用户添加分数时，我们使用`zadd`命令将用户ID作为元素，分数作为分值添加到有序集合中。获取用户排名时，我们使用`zrevrank`命令从高到低获取用户的排名。获取排行榜时，我们使用`zrevrangeWithScores`命令从高到低获取排行榜的用户和分数。

**6. 如何使用Redis实现一个简单的消息队列？**

以下是使用Java和Jedis库实现一个简单的消息队列的模拟代码示例。在这个示例中，我们将模拟如何将消息放入队列，以及从队列中获取消息并处理。

```java
import redis.clients.jedis.Jedis;

public class MessageQueueExample {
    private static Jedis jedis = new Jedis("localhost");

    public static void main(String[] args) {
        String queueKey = "message_queue";
        
        // 启动消费者线程
        new Thread(() -> {
            consumeMessages(queueKey);
        }).start();

        // 生产者发送消息
        sendMessage(queueKey, "Hello, Redis!");
        sendMessage(queueKey, "This is a message queue example.");
    }

    // 生产者：发送消息
    private static void sendMessage(String queueKey, String message) {
        // 使用LPUSH命令将消息放入队列
        jedis.lpush(queueKey, message);
    }

    // 消费者：获取并处理消息
    private static void consumeMessages(String queueKey) {
        while (true) {
            // 使用BRPOP命令阻塞地从队列中获取消息，设置超时时间为0表示无限等待
            String message = jedis.brpop(0, queueKey).get(1);
            processMessage(message);
        }
    }

    // 处理消息
    private static void processMessage(String message) {
        System.out.println("Processing message: " + message);
    }
}

```





## Jedis 与 Redisson 有什么区别，底层原理分别是什么。

Jedis 和 Redisson 都是 Java 客户端库，用于与 Redis 数据库进行交互。它们的区别在于功能和设计上的不同。

Jedis 是一个轻量级的 Java 客户端库，专门用于与 Redis 交互。它提供了简单易用的 API，支持 Redis 的所有主要功能。Jedis 底层通过 socket 与 Redis 进行通信，采用阻塞式 IO 模型，每个线程对应一个连接，连接不是线程安全的。

Redisson 是一个基于 Redis 的 Java 客户端库，提供了丰富的分布式 Java 对象和服务。它封装了 Redis 的 Java 客户端 Jedis，提供了更加简单易用的 API，并且支持异步和响应式编程风格。Redisson 支持分布式锁、分布式集合、分布式对象、分布式限流等高级功能。Redisson 底层采用 Netty 实现的 NIO 模型，能够支持高并发的网络通信。

因此，Jedis 更加轻量级、简单易用，适合于基本的 Redis 操作，而 Redisson 则提供了更加丰富的分布式功能和更高效的网络通信方式。选择使用哪个库，可以根据实际业务需求和技术选型来决定。

## Redis常见面试题 ⭐️

**1. 请描述如何使用Redis实现一个简单的缓存系统。遇到缓存击穿、缓存雪崩和缓存并发竞争时，你会如何解决？**

**考核点**：缓存实现原理、问题识别和解决策略 

**解决思路**：使用Redis的数据结构（如字符串、哈希等）存储数据，设置有效期实现缓存过期。对于缓存击穿、缓存雪崩和缓存并发竞争，可以采用布隆过滤器、设置不同过期时间、分布式锁等方法解决。

​		在应用程序中，我们可以使用Redis作为缓存系统，将热点数据存储在Redis中，以减轻对数据库的访问压力并提高响应速度。具体实现时，当应用程序需要访问某个数据时，先去Redis中查询该数据。如果Redis中有该数据（命中缓存），则直接返回给应用程序；如果Redis中没有该数据（缓存未命中），则去数据库中查询数据，然后将查询结果存储在Redis中，并返回给应用程序。

在使用Redis作为缓存系统时，可能会遇到以下问题：

- 缓存击穿：指某个热点key突然失效（如过期），导致大量请求同时直接访问数据库，可能导致数据库压力过大。解决办法包括：对热点key设置永不过期或使用互斥锁，确保同一时间只有一个请求去数据库查询数据并更新缓存。
- 缓存雪崩：指大量缓存数据同时失效，导致大量请求直接访问数据库，可能导致数据库压力过大。解决办法包括：给缓存数据设置不同的过期时间（如添加随机值），以避免同时失效；使用多级缓存，如Redis和本地缓存相结合；使用持久化保证Redis重启后数据不丢失。
- 缓存并发竞争：指多个请求同时访问同一个key，可能导致多个请求都去数据库查询数据并更新缓存。解决办法包括：使用互斥锁，确保同一时间只有一个请求去数据库查询数据并更新缓存。

**2.在电商网站中，如何使用Redis实现一个高性能的购物车功能？**

**考核点**：数据结构选择、性能优化 

**解决思路**：使用Redis的**哈希数据结构**，将购物车中的商品ID与数量进行关联，利用哈希的高性能特点实现高效查询。

底层技术： set user name blake . 

使用Redis实现购物车功能的优势包括：

- 高性能：由于Redis是基于内存的数据存储系统，读写速度非常快，可以大大提高购物车功能的响应速度。
- 减轻数据库压力：将购物车数据存储在Redis中，可以减少对数据库的访问压力。

需要注意的是，购物车数据在Redis中可能会因为内存不足等原因被淘汰，因此需要考虑数据持久化问题。可以选择在用户操作购物车时同时更新数据库，或者**定期将Redis中的购物车数据同步到数据库**。

**3.如何使用Redis的发布-订阅功能实现一个简单的消息队列？**

考核点：发布订阅系统的实现、消息队列的应用 

解决思路：使用Redis的Pub/Sub功能，订阅者订阅一个频道，发布者发布消息到该频道，订阅者收到消息后进行处理。 

底层技术： 使用有序集合List， lpush从左侧插入数据，rpop从右侧取出数据。就能实现FIFO（先进先出）。

**4.请描述如何利用Redis的有序集合（sorted set）实现一个实时排行榜功能。**

考核点：数据结构应用、排行榜功能实现 

解决思路：使用Redis的有序集合数据结构，根据分数对用户ID进行排序，实现高性能的排名查询和排行榜获取。

**5.请介绍一下Redis的持久化机制（RDB和AOF），以及它们的优缺点。**

考核点：持久化机制理解、优缺点分析 

解决思路：介绍RDB和AOF的工作原理、触发条件、优缺点。RDB以二进制格式存储数据快照，AOF记录每个写操作的命令。根据业务需求，可以选择合适的持久化方式。

**6.当Redis的内存占用过高时，你会如何优化Redis配置以降低内存使用？**

考核点：性能优化、配置调整 

解决思路：调整数据结构存储方式、使用内存优化策略、设置适当的数据淘汰策略等。

**7.请解释Redis的主从复制（Master-Slave Replication）机制。如何在Redis中实现高可用和故障转移?**

考核点：主从复制的理解、高可用和故障转移实现 

解决思路：主从复制是指将一个Redis服务器的数据复制到多个从服务器上，实现数据备份和读写分离。在Redis中实现高可用和故障转移的方法包括使用哨兵机制、使用Redis Cluster等。

**8.如果Redis服务器出现性能瓶颈，你会如何诊断问题并提出优化方案？**

考核点：性能诊断、优化方案 

解决思路：通过Redis性能监控工具、日志分析等方法定位性能瓶颈，提出相应的优化方案。例如调整Redis配置、优化数据结构、合理利用缓存、进行代码优化等。

**9.如何使用Redis实现分布式锁？请谈谈它的优缺点以及可能的改进方向。**

考核点：分布式锁实现、优缺点分析 

解决思路：使用Redis的字符串数据结构实现分布式锁，通过SETNX和GETSET命令实现加锁和解锁。分布式锁的优点包括解决分布式系统并发竞争的问题，缺点包括可能出现死锁和锁竞争等问题。可以使用乐观锁、自适应过期时间等方法改进分布式锁的实现。

**10.在使用Redis作为缓存时，如何选择合适的数据淘汰策略（Eviction Policy）？**

考核点：缓存策略选择、业务需求分析 

解决思路：Redis提供了多种数据淘汰策略，如LRU、LFU、随机等。在选择淘汰策略时，需要根据业务需求、数据访问模式等因素进行分析，选择合适的策略。可以通过实验、监控等方法来验证策略的效果，并进行相应的调整。



****



# 分布式：

## 分布式session是什么，使用的技术原理是什么？

分布式 Session 是一种将用户会话信息存储在分布式系统中，以便在多台服务器之间共享的解决方案。在分布式系统中，当用户在一台服务器上登录并创建会话时，会话信息会被存储在该服务器的内存中。如果用户请求被转发到另一台服务器上，该服务器无法读取该用户的会话信息，导致用户需要重新登录。

为了解决这个问题，需要将会话信息存储在共享的存储系统中，以便多台服务器之间可以访问该信息。这就是分布式 Session 的基本原理。

在技术实现上，分布式 Session 通常使用以下技术来存储会话信息：

1. **Cookie：使用** Cookie 存储 Session ID，然后将 Session ID 发送给客户端，客户端将在后续的请求中带上该 Session ID。服务器通过 Session ID 来获取会话信息。
2. **数据库：**将会话信息存储在数据库中，多台服务器之间可以共享该数据库。
3. **缓存系统**：将会话信息存储在缓存系统中，例如 Redis、Memcached 等。多台服务器之间可以共享该缓存系统。

以上三种技术都可以实现分布式 Session，但各有优劣。使用 Cookie 存储 Session ID 的方案简单，但安全性较差，容易受到 XSS、CSRF 等攻击。使用数据库或者缓存系统存储 Session 信息的方案相对安全，但需要考虑数据一致性、容灾等问题。

### 按照缓存的方式实现分布式session，对于数据一致性及容灾等问题应该怎么处理及预防

使用缓存系统实现分布式 Session 的方案相对来说是一种性能较高，且实现较为简单的方案。但需要考虑数据一致性及容灾等问题，以下是一些处理及预防方法：

1. **数据一致性**

在分布式系统中，由于缓存系统是多台服务器之间共享的，因此需要考虑数据一致性问题。具体处理方法有：

- 多台服务器使用相同的缓存系统，这样可以确保不同服务器之间使用的是同一个缓存。
- 在更新 Session 信息时，使用分布式锁来避免并发写入的问题，可以使用 Redis 的 SETNX 命令实现分布式锁。
- 可以使用缓存系统的 TTL（生存时间）功能，为 Session 设置一个过期时间，这样当 Session 过期时，缓存系统会自动将其删除。

2. **容灾**

在分布式系统中，需要考虑单点故障等问题，避免系统无法正常运行。具体处理方法有：

- 在使用缓存系统时，需要选择一个可靠性较高的缓存系统，例如 Redis 集群或 Sentinel 集群，可以提高系统的可靠性。
- 对于缓存系统的故障，可以使用缓存的备份机制来避免数据丢失。例如，可以将 Redis 的 AOF 持久化文件复制到备份机器上，以便在 Redis 主节点宕机时快速切换到备份机器上。
- 可以使用负载均衡器来分配请求，避免单台服务器过载。例如，可以使用 Nginx 或者 HAProxy 等负载均衡器。

需要注意的是，缓存系统只是实现分布式 Session 的一种方案，不同的应用场景可能需要选择不同的方案，根据具体的需求进行选择。同时，需要对分布式 Session 系统进行测试，包括压力测试、故障测试、并发测试等，以保证系统的性能和可靠性。



## 分布式ID是什么？

分布式 ID 是指在分布式系统中生成的全局唯一标识符，通常用于标识分布式系统中的不同实体。在分布式系统中，由于多台服务器之间相互独立，因此需要使用分布式 ID 来确保各个实体之间的唯一性。

分布式 ID 的生成通常需要考虑以下几个因素：

1. 全局唯一性：分布式 ID 在全局范围内需要保证唯一性，不同的 ID 不能重复。
2. 高可用性：分布式 ID 生成需要保证高可用性，即在任何时候都可以生成唯一的 ID。
3. 高并发性：分布式系统中的请求通常具有高并发性，因此需要确保分布式 ID 生成器的并发性能。

常见的分布式 ID 生成方案包括：

1. UUID：UUID（Universally Unique Identifier）是一种由网络上的算法通过计算机的网卡、时间戳等数据计算出来的字符串，具有全局唯一性。UUID 在 Java 中可以使用 `java.util.UUID` 类来生成。
2. Snowflake：Snowflake 是 Twitter 开源的分布式 ID 生成算法，通过生成一个 64 位的二进制数字来保证 ID 的唯一性，其中包括了机器 ID、数据中心 ID、时间戳等信息。
3. Leaf：Leaf 是美团开源的分布式 ID 生成器，可以生成全局唯一的 64 位 ID。Leaf 的原理是通过将 ID 的生成工作拆分成多个节点，每个节点只负责生成部分 ID，以此来提高生成性能。

分布式 ID 生成方案的选择需要根据具体的应用场景和需求来确定，需要考虑 ID 的唯一性、生成性能、可读性等因素。



## 分布式id常见的使用场景有哪些？

分布式 ID 具有全局唯一性和高性能等特点，因此常被用于以下场景：

1. 数据库主键：在分布式系统中，每台服务器的数据库表主键需要具有全局唯一性，避免数据冲突。因此，可以使用分布式 ID 作为数据库表的主键。
2. 消息队列消息 ID：在消息队列中，每条消息需要具有全局唯一性，避免消息丢失或重复。因此，可以使用分布式 ID 作为消息的 ID。
3. 分布式锁的 ID：在分布式锁中，锁的名字需要具有全局唯一性，以避免不同的锁互相干扰。因此，可以使用分布式 ID 作为锁的名字。
4. 日志 ID：在分布式系统中，需要对日志进行全局唯一标识，以便在分布式系统中进行日志的聚合和分析。因此，可以使用分布式 ID 作为日志的 ID。
5. 分布式事务 ID：在分布式事务中，需要对分布式事务进行全局唯一标识，以便在不同节点间协调事务。因此，可以使用分布式 ID 作为分布式事务的 ID。

总之，分布式 ID 可以应用于任何需要唯一标识的场景，确保全局唯一性和高性能。





# 什么是单点登录

单点登录（Single Sign-On，SSO）是一种认证机制，它允许用户只需要一次登录，就可以在多个应用程序或系统中访问资源。在单点登录的机制下，用户只需要进行一次身份验证，就可以在多个应用程序或系统中访问受保护的资源，无需再次输入用户名和密码。这样可以减少用户的操作次数，提高用户体验，同时也能够提高系统的安全性，避免因为用户使用弱密码或重复密码等问题导致的安全漏洞。

在单点登录的实现中，通常会有一个认证中心或者统一认证服务器，用户在该服务器上进行一次登录，并获取到一个安全令牌（Token）。然后，用户可以使用该安全令牌来访问其他应用程序或系统中的资源。当用户访问其他应用程序或系统时，该应用程序或系统会将用户的安全令牌发送到认证中心或统一认证服务器进行验证，如果验证通过，则允许用户访问资源。

单点登录的机制可以大大简化用户的认证流程，提高用户体验，同时也能够提高系统的安全性和管理效率，减少重复的身份验证过程。因此，在企业内部、社交网络、电子商务等领域都有广泛的应用。但是，也存在一些安全风险，例如令牌的泄露和窃取，需要采取一些措施来保证系统的安全性。

## 单点登录的风险有哪些

单点登录（Single Sign-On，SSO）技术虽然带来了很多便利，但是也存在一些安全风险，主要包括以下几个方面：

1. 令牌泄露：令牌是 SSO 技术中的核心组件，令牌一旦被泄露，攻击者就可以伪造身份访问系统，造成安全威胁。因此，需要对令牌进行加密、签名等措施来防止令牌的泄露。
2. 令牌窃取：攻击者可以通过各种手段获取用户的令牌，例如 XSS、CSRF 等攻击。因此，需要采用一些措施来防止令牌的窃取，例如使用 HTTPS、添加 CSRF Token 等。
3. 会话劫持：会话劫持是指攻击者在用户身份认证完成之后，利用某些手段获取用户会话标识符并用于自己的非法操作，例如中间人攻击、恶意软件等。因此，需要采用一些措施来防止会话劫持，例如使用 HTTPS、设置 HttpOnly 属性等。
4. 单点故障：单点登录存在单点故障的风险，如果认证服务出现故障，会影响到整个系统的使用。因此，需要采用一些高可用性的措施来保证认证服务的可靠性。
5. 同步问题：在 SSO 系统中，用户信息需要在各个系统之间同步，如果同步不及时或同步失败，会导致用户信息不一致，造成安全风险。因此，需要采用一些同步机制来保证用户信息的一致性。

综上所述，SSO 技术虽然带来了很多便利，但也需要采取一些措施来防止安全风险。在使用 SSO 技术时，需要根据实际情况来选择合适的实现方案，并且需要进行安全评估和测试，以确保系统的安全性和稳定性。

## 针对上述问题，应该采取什么样的解决方案？

为了解决单点登录（SSO）中存在的安全问题，可以采取以下一些解决方案：

1. 令牌加密和签名：对令牌进行加密和签名，可以防止令牌的泄露和篡改，提高系统的安全性。
2. HTTPS：采用 HTTPS 协议来进行数据传输，可以保证数据的机密性和完整性，防止中间人攻击和窃听。
3. CSRF Token：在 SSO 系统中，使用 CSRF Token 来防止 CSRF 攻击，避免攻击者利用用户的浏览器执行非法操作。
4. HttpOnly 属性：在设置 Cookie 时，使用 HttpOnly 属性可以防止攻击者利用 XSS 攻击获取用户的会话标识符。
5. 高可用性：为认证服务提供高可用性的支持，例如使用负载均衡、故障转移等技术，可以避免单点故障。
6. 强密码策略：要求用户使用强密码，并采取一些措施来防止密码的泄露，例如限制密码输入次数、采用多因素认证等。
7. 审计和日志：对用户的操作进行审计和记录，可以帮助发现异常操作和安全事件，及时采取措施进行处理。

总之，在设计和实现 SSO 系统时，需要采用多种措施来保障系统的安全性，避免潜在的安全风险。同时，需要定期进行安全评估和测试，及时发现和解决系统中存在的安全问题。



# 系统性功优化的思路有哪些？

系统性能优化的思路可以分为以下几个方面：

1. 硬件优化：优化服务器的硬件配置，例如增加 CPU、内存、硬盘等，以提高系统的处理性能。
2. 软件优化：对操作系统、数据库、应用程序等进行优化，例如调整参数、升级版本、优化配置等，以提高系统的性能。
3. 网络优化：优化网络环境，例如优化网络拓扑、增加带宽、调整网络参数等，以提高系统的网络性能。
4. 代码优化：对系统代码进行优化，例如使用高效的算法、避免重复计算、优化数据库访问等，以提高系统的运行效率。
5. 缓存优化：使用缓存技术，例如使用 Redis、Memcached 等缓存系统，可以减轻系统的负载，提高系统的响应速度。
6. 负载均衡：使用负载均衡技术，例如使用 Nginx、HAProxy 等负载均衡软件，可以将请求均衡地分配到多台服务器上，提高系统的处理能力。
7. 数据库优化：对数据库进行优化，例如调整参数、添加索引、优化查询语句等，以提高系统的查询性能。
8. 监控优化：对系统进行监控，例如使用监控工具、添加日志、记录性能指标等，可以及时发现和解决性能问题，提高系统的稳定性和可靠性。

以上这些方面都可以对系统进行优化，从而提高系统的性能和稳定性。在实际工作中，需要根据具体的情况选择合适的优化方案，进行有针对性的优化，以达到优化系统性能的目的。





<aside>
💡

官网: https://www.redis.net.cn/tutorial/3504.html

推荐视频:  https://www.bilibili.com/video/BV18jBiYpEDJ/?spm_id_from=333.1387.collection.video_card.click&vd_source=9a12395c7a339b9d9b5e8755481ae784

</aside>

# Redis介绍

### **1. 技术溯源（为什么要有Redis？）**

**问题背景：**

- 2009年Salvatore Sanfilippo为解决LLOOGG实时日志分析系统的性能瓶颈而开发
- 传统痛点：
    - 磁盘数据库（如MySQL）在读写频繁场景下IO成为瓶颈（机械硬盘寻道时间约10ms vs 内存访问约100ns）
    - Memcached仅支持简单Key-Value，缺乏数据结构表达能力
    - 缓存雪崩、穿透等场景缺乏原生解决方案

**替代方案演进：**

```
磁盘数据库 → Memcached → Redis（内存数据库+数据结构服务）
```

---

### **2. 核心设计思想（不变的本质）**

**第一性原理：**

- 通过内存计算实现亚毫秒级数据访问
- 用丰富的数据结构模型解决特定场景问题
- 在持久化与性能间寻找最佳平衡点

**关键决策与Trade-off：**

| 设计选择 | 优势 | 代价 |
| --- | --- | --- |
| 单线程模型 | 避免锁竞争，原子性保证 | 无法充分利用多核CPU |
| 异步持久化 | 保持高性能 | 可能丢失最后N秒数据 |
| 内存限制 | 强制数据精选 | 数据集受物理内存制约 |

---

### **3. 认知脚手架（三层理解法）**

### **基础层：现实类比**

- **快递柜系统**：
    - 每个格子（Key）存放不同包裹（Value）
    - 特殊货架：冷藏柜（Hash）、排序货架（ZSet）
    - 临时储物柜（过期时间）
    - 寄存凭证（持久化到保管室）

### **实现层：核心机制**

**数据结构引擎：**

```python
# 简化的RedisObject结构
class RedisObject:
    def __init__(self):
        self.type = None  # string/hash/list等
        self.encoding = None  # 实际存储格式
        self.ptr = None  # 指向数据的指针
        self.lru = 0  # 最近使用时间

```

**内存管理：**

```
[Redis内存布局]
| 数据区 | → | 索引字典 | → | 共享对象池 | → | 内存碎片 |

```

### **哲学层：设计范式**

- **空间换时间**：所有数据常驻内存
- **模式匹配**：通过数据结构匹配业务场景
- **最终一致性**：异步持久化策略

---

### **4. 技术拓扑定位**

**知识体系位置：**

```
分布式系统 → 缓存中间件 → 内存数据库
```

**技术对比矩阵：**

|  | Redis | Memcached | Kafka |
| --- | --- | --- | --- |
| 数据模型 | 多数据结构 | Key-Value | 消息流 |
| 持久化 | 支持 | 不支持 | 磁盘持久化 |
| 集群方案 | Redis Cluster | 无原生方案 | Partition机制 |
| 典型场景 | 缓存/计数器 | 简单缓存 | 消息队列 |

---

### **5. 面试视角**

**高频考点：**

1. 为什么单线程还能高性能？
    - **内存操作 + IO多路复用 + 无锁设计**
2. 持久化机制（RDB vs AOF）
    - **RDB(Redis DataBase)：快照方式,也是默认方式，bgsave fork子进程**
        
        **RDB 持久化**是 Redis 中的默认持久化方式，它通过生成数据快照（snapshot）来实现持久化。定期将数据库中的数据保存到一个二进制文件中（默认文件名为 `dump.rdb`）。
        
        ### 工作原理：
        
        - 在指定的时间间隔内，Redis 会将内存中的数据快照保存到硬盘（`dump.rdb` 文件）。
        - 可以配置多个时间间隔，当某些条件满足时，Redis 会自动生成 RDB 快照。
        - 快照是 Redis 在内存中数据的一个完全拷贝，存储在 RDB 文件中。RDB 文件是二进制格式，通常比 JSON 或文本格式占用空间更小。
        
        ### 配置：
        
        在 `redis.conf` 配置文件中，你可以看到类似以下配置项：
        
        ```bash
        save 900 1    # 900 秒内至少有 1 个键发生变化时，生成 RDB 快照
        save 300 10   # 300 秒内至少有 10 个键发生变化时，生成 RDB 快照
        save 60 10000 # 60 秒内至少有 10,000 个键发生变化时，生成 RDB 快照
        ```
        
        ### 优点：
        
        - **性能好**：RDB 快照是通过 fork 出一个子进程来完成的，这样可以避免阻塞主进程，因此对 Redis 的性能影响较小。
        - **适用于备份**：RDB 文件存储了完整的数据库数据，可以用作备份。恢复速度较快。
        - **压缩存储**：RDB 文件一般比 AOF 文件占用更少的磁盘空间。
        
        ### 缺点：
        
        - **数据丢失**：RDB 是通过定期生成快照来持久化数据的。如果 Redis 崩溃，最后一次的 RDB 快照保存的数据会丢失，因此会有一定的数据丢失风险。特别是在保存间隔较长时，丢失的数据可能更多。
        - **持久化延迟**：RDB 快照生成时会有一定延迟，尤其是在数据量非常大的时候，生成 RDB 文件会变得耗时。
        
        ### 使用场景：
        
        RDB 适合用在对数据丢失要求不高、但要求快速启动的场景，比如用于备份、灾备恢复等。
        
    - **AOF（Append Only File）：追加日志，重写机制**
        
        **AOF 持久化**是通过记录 Redis 的所有写操作来保证数据的持久化。每当 Redis 执行写操作（如 `SET`、`DEL` 等），它就会把该操作以日志的形式追加到 AOF 文件中。AOF 文件默认名为 `appendonly.aof`。
        
        ### 工作原理：
        
        - AOF 会记录每个写操作，日志文件会按顺序追加写入。例如，`SET key value` 会被追加到 AOF 文件中。
        - Redis 每次启动时，都会读取 AOF 文件中的命令并按顺序重放，从而恢复数据。
        - AOF 持久化策略可以配置为不同的刷盘方式（同步策略）：
            - **每次写操作都同步（`appendfsync always`）**：每个写操作都立刻写入磁盘，保证数据不丢失。
            - **每秒钟同步一次（`appendfsync everysec`）**：每秒钟将写操作刷新到磁盘，这是一种折衷的方式，既保证了数据持久性，又相对节省性能。
            - **不做同步（`appendfsync no`）**：完全交给操作系统，由操作系统决定何时将数据写入磁盘，这种方式最快，但风险较大，可能会丢失最近的写操作。
        
        ### 优点：
        
        - **持久性强**：AOF 记录了所有写操作，恢复时可以精确到最后一个操作，数据丢失的风险较小。
        - **灵活性高**：可以选择不同的刷盘策略以平衡性能和数据安全性。
        - **可以恢复到更细粒度**：相比于 RDB 的快照，AOF 能记录所有操作，并允许恢复到某一时刻的状态。
        
        ### 缺点：
        
        - **文件增大**：AOF 文件会随着时间增长，可能变得非常大，特别是在大量写操作的情况下。
        - **性能开销**：虽然 AOF 的默认刷盘策略是每秒同步一次（`everysec`），但频繁的 I/O 操作会对性能产生一定影响。尤其是在频繁写入数据时，AOF 的性能可能较差。
        - **启动较慢**：AOF 文件的加载速度相对较慢，因为每个写操作都需要执行(**查新执行每个命令将数据写入到内存中**)。
        
        ### 使用场景：
        
        AOF 适用于需要保证数据持久性、但对性能要求相对宽松的场景。尤其适用于数据库崩溃时需要尽量减少数据丢失的场景。
        
    - **组合使用**
        
        ### RDB 和 AOF 组合使用
        
        为了平衡性能和数据安全性，Redis 允许将 RDB 和 AOF 结合使用。这种组合方式通常用于需要较强持久化保障，同时希望享受两者优点的场景。
        
        - **RDB 主要用于定期备份**，并且在 Redis 启动时快速加载数据。
        - **AOF 主要用于实时持久化**，记录所有写操作，确保数据不丢失。
        
        ### 使用方式：
        
        **可以在 Redis 配置中启用 RDB 和 AOF 持久化，Redis 会在崩溃后首先恢复 AOF 文件(保证数据不丢失,恢复精度高), 如果AOF文件不存在或者损坏了,再通过 RDB 文件恢复数据(速度快,但是精度低,可能会丢失最后一次快照之后的数据)。**
        
        ### 优点：
        
        - **高可靠性**：RDB 提供快速的数据恢复，而 AOF 确保数据不会丢失。
        - **灵活性**：可以根据实际需求调整持久化策略，在保证数据安全的同时，优化性能。
        
        ### 缺点：
        
        - **磁盘占用**：使用两种持久化机制会增加磁盘的存储压力。
        - **性能开销**：同时启用两种持久化机制，可能会增加 I/O 操作，从而影响 Redis 的性能。
3. redis重启执行AOF文件中命令时, 对于带有过期时间的TTL命令是怎么处理过期时间的?
    - AOF 文件中记录的是执行时的命令，即 `SET name zk EX 5h`。
    - **事实上**，Redis 并没有内置机制来自动修正过期时间。它只是简单地在重启时执行 AOF 文件中的命令`SET name zk EX 5`，并直接将过期时间重新设置为命令中指定的值。这意味着在重启后，过期时间是 **相对于重启时的当前时间** 重新计算的，并不会减去已过的时间。
    - **原因:**
        
        主要是出于**简化实现**和**性能的考虑**。重启时，如果要重新计算过期时间，Redis 需要维护精确的时间戳和计算每个命令的实际 TTL，这会增加额外的复杂度。
        
        此外，Redis 的过期机制本身就是基于“懒删除”（Lazy Expiration）的，即键的过期时间并不是严格按照系统时钟来进行精确控制的，而是通过**定期扫描**和**按需删除**来实现的。这种设计大大简化了过期时间的管理。
        
4. Redis的过期机制是什么?
    - Redis 的过期机制采用 **懒删除 + 定期删除** 的策略。
    - **懒删除**：只有当某个键被访问时，才会检查它是否过期，如果过期会删除该键。
    - **定期删除**：Redis 会定期扫描一部分键，并删除过期的键。
    - **主动删除:**
        
        在某些情况下，如果 Redis 达到最大内存限制（`maxmemory`），它会启动主动删除机制来腾出空间。Redis 提供了多种 **驱逐策略**（Eviction Policy），比如：
        
        - **LRU（Least Recently Used）**：删除最近最少使用的键。
        - **LFU（Least Frequently Used）**：删除使用最少的键。
        - **随机删除**：随机删除一些键。
    - 查询过期键：即使过期，键仍然可以被查询到，直到 Redis 删除它们。如果过期，查询结果会返回 `nil`（或 `null`）。
    - Redis 过期机制的设计可以有效减少性能开销，但也有可能导致过期键在短期内占用内存，因此合理配置删除策略非常重要。
5. Redis的淘汰策略(当Redis达到最大内存限制时,处理过多的数据,通过合适的淘汰策略，Redis 可以根据具体的需求决定哪些数据应该被移除，从而腾出内存空间):
    
    Redis 的 **淘汰策略**（Eviction Policy）决定了当 Redis 达到最大内存限制时，如何处理过多的数据。通过合适的淘汰策略，Redis 可以根据具体的需求决定哪些数据应该被移除，从而腾出内存空间。
    
    Redis 提供了多种淘汰策略，适应不同的场景和使用需求。下面我们详细讨论一下这些淘汰策略。
    
    - 1. **淘汰策略概览**
        
        Redis 主要提供以下几种淘汰策略，可以通过配置项 `maxmemory-policy` 来设置（`maxmemory` 设置了最大内存限制，当 Redis 达到这个限制时，会根据设置的淘汰策略决定删除哪些键）。
        
        ### 1.1 **noeviction** (默认)
        
        - **含义**：不淘汰任何键，当内存达到 `maxmemory` 限制时，Redis 会返回错误（`OOM command not allowed when used memory > 'maxmemory'`）。
        - **适用场景**：适合那些对数据的持久性要求极高，不能丢失数据的场景。
        - **缺点**：一旦内存达到限制，Redis 将无法再接收任何写请求，直到内存被清理或配置调整。
        
        ### 1.2 **volatile-lru**
        
        - **含义**：删除 **设置了过期时间的键**，并使用 **LRU（Least Recently Used）** 策略删除最近最少使用的键。
        - **适用场景**：适合需要定期清除过期数据，且优先删除那些不常用数据的场景。比如，缓存系统中某些过期的数据可能不再被访问，可以先删除这些数据。
        - **缺点**：如果有大量的过期键，可能会导致频繁删除。
        
        ### 1.3 **allkeys-lru**
        
        - **含义**：删除 **所有键**，并使用 **LRU** 策略删除最近最少使用的键。
        - **适用场景**：适合对所有键进行 LRU 淘汰的场景。对于不在乎是否过期的数据，LRU 是一种简单有效的淘汰策略，能清理不常用的数据。
        - **缺点**：可能会删除一些依赖不频繁访问的键，造成缓存命中率下降。
        
        ### 1.4 **volatile-ttl**
        
        - **含义**：删除 **设置了过期时间的键**，优先删除那些 **TTL（剩余过期时间）最短的键**。
        - **适用场景**：适用于那些希望优先删除即将过期的键的场景。这有助于保持缓存中的数据是最新的，并且尽可能减少即将过期的键所占用的内存。
        - **缺点**：如果有很多即将过期的键，它们可能会被频繁删除。
        
        ### 1.5 **allkeys-random**
        
        - **含义**：删除 **所有键**，采用 **随机** 策略删除。
        - **适用场景**：适用于缓存较为松散、不需要精确控制内存使用的场景。Redis 会随机选择一些键删除，达到腾出内存的目的。
        - **缺点**：可能会删除重要的或常用的键，不适合缓存系统，因为会影响缓存命中率。
        
        ### 1.6 **volatile-random**
        
        - **含义**：删除 **设置了过期时间的键**，并采用 **随机** 策略删除。
        - **适用场景**：适用于需要删除一部分过期键，但不关心删除哪一个的场景。
        - **缺点**：可能会删除一些重要的过期键，而不会考虑它们的使用频率或过期时间。
        
        ### 1.7 **volatile-lfu**
        
        - **含义**：删除 **设置了过期时间的键**，并使用 **LFU（Least Frequently Used）** 策略，优先删除最少被访问的键。
        - **适用场景**：适用于缓存系统中需要精细控制哪些过期数据应该被删除的场景。LFU 策略通过统计每个键的访问频率来决定淘汰哪些键，可以保留经常使用的键。
        - **缺点**：LFU 的实现复杂，可能需要更多的计算资源。
        
        ### 1.8 **allkeys-lfu**
        
        - **含义**：删除 **所有键**，并使用 **LFU** 策略，优先删除最少被访问的键。
        - **适用场景**：适用于更为精细的缓存淘汰机制，通过访问频率来选择要淘汰的键，可以保证常用数据优先保留。
        - **缺点**：实现相对复杂，并且 LFU 策略需要维护额外的计数器和元数据，会增加一定的开销。
    - 2. **淘汰策略详细分析**
        
        ### 2.1 **LRU（Least Recently Used）**
        
        - **工作原理**：LRU 策略基于“最近最少使用”原则，即在内存满时，会优先淘汰那些最近最少被访问的键。这样常用的键会被优先保留，较少使用的键会被删除。
        - **适用场景**：适用于缓存、会话数据等场景，能有效提高缓存命中率。
        - **实现方式**：Redis 在每个键上维护一个时间戳或访问计数，以便知道哪个键最久未被访问。
        
        ### 2.2 **LFU（Least Frequently Used）**
        
        - **工作原理**：LFU 策略基于“最少使用”原则，即在内存满时，会优先淘汰那些被访问次数最少的键。这对于某些长期被访问但短期内不频繁访问的数据尤其有效。
        - **适用场景**：适用于需要精确控制缓存命中率和内存占用的场景。比如，大数据量缓存的场景，保证高频访问的数据优先保留。
        - **实现方式**：Redis 通过统计每个键的访问次数，记录最少使用的键。
        
        ### 2.3 **随机淘汰**
        
        - **工作原理**：随机选择一些键进行删除，不考虑键的访问频率或过期时间。
        - **适用场景**：适用于对内存占用不敏感，且不关心哪些键被淘汰的场景。
        - **缺点**：无法保证删除的是“最不重要”的数据，可能会影响缓存的效果。
        
        ### 2.4 **TTL（Time-to-Live）与过期时间**
        
        - **TTL 策略**：Redis 中支持对键设置过期时间，过期时间到期后，键会被删除。`volatile-lru` 和 `volatile-ttl` 策略可以通过 TTL 来优先删除即将过期的键。
        - **适用场景**：适用于缓存和 session 存储场景，能够减少不必要的内存占用。
    - 3. **如何配置淘汰策略**
        
        可以通过修改 Redis 配置文件或者通过命令来设置 `maxmemory-policy`，指定当内存达到上限时 Redis 应该使用的淘汰策略。例如：
        
        ```bash
        # 配置文件中设置最大内存为 1GB，淘汰策略为 LRU
        maxmemory 1gb
        maxmemory-policy allkeys-lru
        ```
        
    - 4. **总结**
        
        Redis 的淘汰策略提供了多种方式来管理内存限制下的数据清理，具体的策略选择要根据你的应用场景来决定：
        
        - **缓存**：LRU 和 LFU 是常见的淘汰策略，适用于频繁访问的数据。
        - **会话存储**：TTL 结合 `volatile-lru` 或 `volatile-ttl` 更适合这些场景。
        - **不关心数据优先级**：`allkeys-random` 和 `volatile-random` 可以快速腾出内存。
        
        选择合适的淘汰策略能够有效提高 Redis 的性能，同时保证数据的合理存储和清理。根据业务需求调整这些策略，可以让你更加高效地使用 Redis。
        
6. 缓存异常场景解决方案
    - 穿透(redis与数据库中都不存在)：布隆过滤器(会出现误判: 当布隆过滤器中不存在时一定不存在, 如果布隆过滤器中存在,redis中可能不存在.)
    - 雪崩(大量key在同一时间失效)：随机过期时间
    - **击穿**(高并发时,多个线程同时查询一个过期的key时,会同时打到数据库)：互斥锁或者分布式锁, 保证多个线程同时访问过期key时, 只让一个线程去数据库查询, 将查询到的缓存到redis中, 其他线程直接中redis缓存中获取.
        - **真实的项目中解决缓存击穿的方案:**
        
        ```java
        方案一: 提前预热(最优)
        思路: 在热点数据的TTL过期前, 提前主动刷新缓存, 确保缓存不会实效. 
        适用场景：适用于热点数据稳定的业务，如热点新闻、商品详情页、明星微博等。
        方案二: 缓存永不过期 + 后台异步更新
        思路:  Redis 不主动删除缓存，而是让缓存永不过期（即 不设置 TTL）。由 后台异步任务 定期同步数据库数据。
        实现方式:  redis永不过期, 当数据库数据变化时, 异步更新redis中的数据.  
        
        ```
        
7. 集群方案（主从复制、哨兵、Cluster）

**常见误解：**

- ❌ "Redis是纯内存数据库" → 支持持久化到磁盘
- ❌ "Redis事务支持ACID" → 仅保证隔离性和原子性

**深度延展建议：**

- 研究Redis的渐进式rehash过程
- 分析跳跃表在ZSet中的实现
- 探索Redis Module机制（如RedisSearch）

---

### **自我检测**

试着用3W-H法回答：

- Why：为什么需要Redis而不用MySQL直接缓存？
- What：Sorted Set底层用了哪些数据结构？
- When：什么场景下应该选择Redis而不是Kafka？
- How：如何用Redis实现分布式锁？

需要我针对某个模块深入展开吗？比如数据结构实现、持久化机制或集群方案？

# Redis面试题及基础总结

## 1、redis数据结构针对value来说的

- String类型（一个key对应一个value）、Hash类型（hashtable）、List类型（列表，底层是双向链表，可以做阻塞队列，lpush--brpop）、Set类型（无序，不可重复）、Sorted-Set通过score来排序

## 2、Redis如何存储对象

- 如果对象结构简单，且不需要考虑特别高效的存储（如涉及大量复杂嵌套对象），**JSON 序列化可能会占用较少的内存(要实现序列化接口)**，同时它的可读性也更强。
- 对于 **更复杂的对象结构** 或需要优化存储和性能的场景，**二进制序列化可能占用更少的内存**，并且具有更高的反序列化效率。

## 3、Redis单线程的,为什么能扛高并发

<aside>
💡

Redis 的高并发能力，主要归功于：

1. **单线程，避免加锁开销**，确保了数据一致性和更少的 CPU 资源消耗。
2. **基于内存，读写速度极快**，不像传统数据库那样受磁盘 I/O 影响。
3. **使用 I/O 多路复用**，让单个线程能同时处理多个连接，而不会陷入阻塞。

换句话说，Redis **并不是靠多线程取胜，而是靠减少开销 + 高效的 I/O 机制** 来应对高并发。

</aside>

### 3.1、I/O多路复用的底层机

| 机制 | 监听方式 | 复杂度 | 是否轮询 | 适用场景 |
| --- | --- | --- | --- | --- |
| `select` | 数组存储 fd，每次遍历 | O(n) | 轮询整个列表 | 小规模连接 |
| `poll` | 链表存储 fd，每次遍历 | O(n) | 轮询整个列表 | 中等并发 |
| `epoll` | 红黑树存储 fd，事件触发 | O(1) | **事件驱动** | 高并发应用（Redis、Nginx） |
| `kqueue` | 事件触发 | O(1) | **事件驱动** | macOS / FreeBSD |
- **通俗易懂地理解 I/O 多路复用**
    
    **现实世界的类比**
    
    假设你是一个快递员，你要去派送包裹：
    
    - **普通多线程方式**：你派了 10 个快递员，每个人去一户人家敲门送快递（每个线程对应一个请求）。但这需要额外管理多个快递员，并处理他们之间的调度和协调（就像多线程需要加锁管理）。
    - **I/O 多路复用**：你是一个 **超级快递员**，你带了一个 **智能通知器**，可以同时监视 100 户人家。当有人开门（数据准备好），你就立刻上去送快递（处理请求）。这样，你一个人就能高效处理多个快递，而不需要雇佣 100 个快递员。
    
    Redis 的 I/O 多路复用就像这个 **智能通知器**，它可以同时监听多个客户端连接，一旦有数据可读，它立刻去处理，而不是一个一个地轮询所有连接。
    
- **I/O 多路复用的底层机制**
    
    在操作系统层面，Redis 使用 **epoll（Linux）/ kqueue（macOS）/ select（Windows）** 实现 I/O 多路复用。我们以 `epoll` 为例：
    
    ### **传统的阻塞 I/O（低效）**
    
    - 以前的做法是 **每个连接占用一个线程**，如果你有 1000 个连接，就需要 1000 个线程，每个线程都在等待数据，浪费大量 CPU 和内存。
    - 这种模式叫 **"1 连接 = 1 线程"**，很难高效扩展。
    
    ### **I/O 多路复用的方式（高效）**
    
    - Redis 只使用 **一个线程**，但它使用 `epoll` 监听 **所有的连接**。
    - `epoll` 机制能检测哪些连接 **有数据可读**，只处理这些连接，而不是挨个去检查所有连接（像以前的 `select/poll` 那样）。
    - 这样，Redis 就能 **用一个线程同时处理成千上万个连接**，大幅提升并发能力。
    

## 4、项目中如何实现的分布式锁

采用Redisson(redis的一个java)客户端,它提供了 **分布式锁（Distributed Lock）** 的高层封装，简化了 Redis 原生 `SET NX EX` 方案，并自动处理**锁续约、宕机恢复、超时控制**等问题

```java
// 可重入锁
RLock lock = redisson.getLock("my_lock");
lock.lock();  // 获取锁（默认 30s 过期）
try {
    // 执行业务逻辑
} finally {
    lock.unlock();  // 释放锁
}

// 这个 API 看起来很简单，但 Redisson 内部做了很多事情 来解决 Redis 分布式锁的各种问题，我们逐个分析
```

**核心步骤:** 

1. **加锁**:  `SET my_lock UUID NX PX 30000 # 30s 过期` 这里UUID是客户端生成的唯一表示, 保证只有加锁的进程才能释放锁. 
2. **自动续约(watchdog机制):** 
    1. Redisson 采用 **后台守护线程（Watchdog）** 定期 **检查锁是否仍然被持有:**
        1. 如果任务仍在执行, 自动**续约锁的过期时间,** 防止锁意外释放:  `EXPIRE my_lock 30 # 续约 30s`
        2. 默认每10秒检查一次, 如果任务完成了,就不在续约. 
3. **释放锁:**  
    
    ```java
    // 锁释放前, Redisson会检查锁的唯一标识, 这样防止误删别人的锁. 
    if (redis.get("my_lock") == UUID) {
        redis.del("my_lock");  // 只有持有锁的进程才能删除锁
    }
    ```

